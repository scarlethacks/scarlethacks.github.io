{"version":3,"sources":["apply.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","RegExp","escape","replace","undefined","$","jQuery","csv","defaults","separator","delimiter","headers","hooks","castToScalar","value","state","hasDot","isNaN","test","parseFloat","integer","parseInt","parsers","parse","options","endOfEntry","start","rowNum","entry","colNum","onParseEntry","data","push","hookVal","end","exit","endOfValue","onParseValue","hook","escSeparator","escDelimiter","match","matchSrc","source","m0","splitLines","endOfLine","entries","prevChar","substr","parseEntry","helpers","collectPropertyNames","objects","propName","props","hasOwnProperty","indexOf","toArray","callback","config","toArrays","onPreParse","onPostParse","toObjects","lines","transform","headerOptions","headerLine","len","object","j","fromArrays","arrays","line","lineValues","output","strValue","toString","escMatcher","search","join","fromObjects","sortOrder","manualOrder","origObjects","sort","propsManual","concat","p","csvEntry2Array","csv2Array","csv2Dictionary","this","2","document","getElementById","select","button","get","schools","forEach","row","school","option","createElement","setAttribute","innerText","appendChild","removeAttribute","addEventListener","yourSchool","console","log","window","location","jquery-csv"],"mappings":"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","file":"../apply.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * jQuery-csv (jQuery Plugin)\n *\n * This document is licensed as free software under the terms of the\n * MIT License: http://www.opensource.org/licenses/mit-license.php\n *\n * Acknowledgements:\n * The original design and influence to implement this library as a jquery\n * plugin is influenced by jquery-json (http://code.google.com/p/jquery-json/).\n * If you're looking to use native JSON.Stringify but want additional backwards\n * compatibility for browsers that don't support it, I highly recommend you\n * check it out.\n *\n * A special thanks goes out to rwk@acm.org for providing a lot of valuable\n * feedback to the project including the core for the new FSM\n * (Finite State Machine) parsers. If you're looking for a stable TSV parser\n * be sure to take a look at jquery-tsv (http://code.google.com/p/jquery-tsv/).\n\n * For legal purposes I'll include the \"NO WARRANTY EXPRESSED OR IMPLIED.\n * USE AT YOUR OWN RISK.\". Which, in 'layman's terms' means, by using this\n * library you are accepting responsibility if it breaks your code.\n *\n * Legal jargon aside, I will do my best to provide a useful and stable core\n * that can effectively be built on.\n *\n * Copyrighted 2012 by Evan Plaice.\n */\n\nRegExp.escape= function(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\n(function (undefined) {\n  'use strict';\n\n  var $;\n\n  // to keep backwards compatibility\n  if (typeof jQuery !== 'undefined' && jQuery) {\n    $ = jQuery;\n  } else {\n    $ = {};\n  }\n\n\n  /**\n   * jQuery.csv.defaults\n   * Encapsulates the method paramater defaults for the CSV plugin module.\n   */\n\n  $.csv = {\n    defaults: {\n      separator:',',\n      delimiter:'\"',\n      headers:true\n    },\n\n    hooks: {\n      castToScalar: function(value, state) {\n        var hasDot = /\\./;\n        if (isNaN(value)) {\n          return value;\n        } else {\n          if (hasDot.test(value)) {\n            return parseFloat(value);\n          } else {\n            var integer = parseInt(value);\n            if(isNaN(integer)) {\n              return null;\n            } else {\n              return integer;\n            }\n          }\n        }\n      }\n    },\n\n    parsers: {\n      parse: function(csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter;\n\n        // set initial state if it's missing\n        if(!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n        if(!options.state.colNum) {\n          options.state.colNum = 1;\n        }\n\n        // clear initial state\n        var data = [];\n        var entry = [];\n        var state = 0;\n        var value = '';\n        var exit = false;\n\n        function endOfEntry() {\n          // reset the state\n          state = 0;\n          value = '';\n\n          // if 'start' hasn't been met, don't output\n          if(options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = [];\n            options.state.rowNum++;\n            options.state.colNum = 1;\n            return;\n          }\n          \n          if(options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            data.push(entry);\n          } else {\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if(hookVal !== false) {\n              data.push(hookVal);\n            }\n          }\n          //console.log('entry:' + entry);\n          \n          // cleanup\n          entry = [];\n\n          // if 'end' is met, stop parsing\n          if(options.end && options.state.rowNum >= options.end) {\n            exit = true;\n          }\n          \n          // update global state\n          options.state.rowNum++;\n          options.state.colNum = 1;\n        }\n\n        function endOfValue() {\n          if(options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value);\n          } else {\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\n            // false skips the row, configurable through a hook\n            if(hook !== false) {\n              entry.push(hook);\n            }\n          }\n          //console.log('value:' + value);\n          // reset the state\n          value = '';\n          state = 0;\n          // update global state\n          options.state.colNum++;\n        }\n\n        // escape regex-specific control chars\n        var escSeparator = RegExp.escape(separator);\n        var escDelimiter = RegExp.escape(delimiter);\n\n        // compile the regEx str using the custom delimiter/separator\n        var match = /(D|S|\\r\\n|\\n|\\r|[^DS\\r\\n]+)/;\n        var matchSrc = match.source;\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\n        match = new RegExp(matchSrc, 'gm');\n\n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(match, function (m0) {\n          if(exit) {\n            return;\n          }\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += '';\n                endOfValue();\n                break;\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                state = 1;\n                break;\n              }\n              // null last value\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              }\n              // un-delimited value\n              value += m0;\n              state = 3;\n              break;\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2;\n                break;\n              }\n              // delimited data\n              value += m0;\n              state = 1;\n              break;\n\n            // delimiter found in delimited input\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0;\n                state = 1;\n                break;\n              }\n              // null value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // end of entry\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              }\n              // broken paser?\n              throw new Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n\n            // un-delimited input\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // end of entry\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              }\n              if (m0 === delimiter) {\n              // non-compliant data\n                throw new Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n              }\n              // broken parser?\n              throw new Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n            default:\n              // shenanigans\n              throw new Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n          }\n          //console.log('val:' + m0 + ' state:' + state);\n        });\n\n        // submit the last entry\n        // ignore null last line\n        if(entry.length !== 0) {\n          endOfValue();\n          endOfEntry();\n        }\n\n        return data;\n      },\n\n      // a csv-specific line splitter\n      splitLines: function(csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter;\n\n        // set initial state if it's missing\n        if(!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n\n        // clear initial state\n        var entries = [];\n        var state = 0;\n        var entry = '';\n        var exit = false;\n\n        function endOfLine() {          \n          // reset the state\n          state = 0;\n          \n          // if 'start' hasn't been met, don't output\n          if(options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = '';\n            options.state.rowNum++;\n            return;\n          }\n          \n          if(options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            entries.push(entry);\n          } else {\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if(hookVal !== false) {\n              entries.push(hookVal);\n            }\n          }\n\n          // cleanup\n          entry = '';\n\n          // if 'end' is met, stop parsing\n          if(options.end && options.state.rowNum >= options.end) {\n            exit = true;\n          }\n          \n          // update global state\n          options.state.rowNum++;\n        }\n\n        // escape regex-specific control chars\n        var escSeparator = RegExp.escape(separator);\n        var escDelimiter = RegExp.escape(delimiter);\n\n        // compile the regEx str using the custom delimiter/separator\n        var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\n        var matchSrc = match.source;\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\n        match = new RegExp(matchSrc, 'gm');\n\n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(match, function (m0) {\n          if(exit) {\n            return;\n          }\n          switch (state) {\n            // the start of a value/entry\n            case 0:\n              // null value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                entry += m0;\n                state = 1;\n                break;\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              }\n              // phantom carriage return\n              if (/^\\r$/.test(m0)) {\n                break;\n              }\n              // un-delimit value\n              entry += m0;\n              state = 3;\n              break;\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                entry += m0;\n                state = 2;\n                break;\n              }\n              // delimited data\n              entry += m0;\n              state = 1;\n              break;\n\n            // delimiter found in delimited input\n            case 2:\n              // escaped delimiter?\n              var prevChar = entry.substr(entry.length - 1);\n              if (m0 === delimiter && prevChar === delimiter) {\n                entry += m0;\n                state = 1;\n                break;\n              }\n              // end of value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              }\n              // phantom carriage return\n              if (m0 === '\\r') {\n                break;\n              }\n              // broken paser?\n              throw new Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\n\n            // un-delimited input\n            case 3:\n              // null value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              }\n              // phantom carriage return\n              if (m0 === '\\r') {\n                break;\n              }\n              // non-compliant data\n              if (m0 === delimiter) {\n                throw new Error('CSVDataError: Illegal quote [Row:' + options.state.rowNum + ']');\n              }\n              // broken parser?\n              throw new Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\n            default:\n              // shenanigans\n              throw new Error('CSVDataError: Unknown state [Row:' + options.state.rowNum + ']');\n          }\n          //console.log('val:' + m0 + ' state:' + state);\n        });\n\n        // submit the last entry\n        // ignore null last line\n        if(entry !== '') {\n          endOfLine();\n        }\n\n        return entries;\n      },\n\n      // a csv entry parser\n      parseEntry: function(csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter;\n        \n        // set initial state if it's missing\n        if(!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n        if(!options.state.colNum) {\n          options.state.colNum = 1;\n        }\n\n        // clear initial state\n        var entry = [];\n        var state = 0;\n        var value = '';\n\n        function endOfValue() {\n          if(options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value);\n          } else {\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\n            // false skips the value, configurable through a hook\n            if(hook !== false) {\n              entry.push(hook);\n            }\n          }\n          // reset the state\n          value = '';\n          state = 0;\n          // update global state\n          options.state.colNum++;\n        }\n\n        // checked for a cached regEx first\n        if(!options.match) {\n          // escape regex-specific control chars\n          var escSeparator = RegExp.escape(separator);\n          var escDelimiter = RegExp.escape(delimiter);\n          \n          // compile the regEx str using the custom delimiter/separator\n          var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\n          var matchSrc = match.source;\n          matchSrc = matchSrc.replace(/S/g, escSeparator);\n          matchSrc = matchSrc.replace(/D/g, escDelimiter);\n          options.match = new RegExp(matchSrc, 'gm');\n        }\n\n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(options.match, function (m0) {\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += '';\n                endOfValue();\n                break;\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                state = 1;\n                break;\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              }\n              // un-delimited value\n              value += m0;\n              state = 3;\n              break;\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2;\n                break;\n              }\n              // delimited data\n              value += m0;\n              state = 1;\n              break;\n\n            // delimiter found in delimited input\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0;\n                state = 1;\n                break;\n              }\n              // null value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              }\n              // broken paser?\n              throw new Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n\n            // un-delimited input\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              }\n              // non-compliant data\n              if (m0 === delimiter) {\n                throw new Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n              }\n              // broken parser?\n              throw new Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n            default:\n              // shenanigans\n              throw new Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n          }\n          //console.log('val:' + m0 + ' state:' + state);\n        });\n\n        // submit the last value\n        endOfValue();\n\n        return entry;\n      }\n    },\n\n    helpers: {\n\n      /**\n       * $.csv.helpers.collectPropertyNames(objectsArray)\n       * Collects all unique property names from all passed objects.\n       *\n       * @param {Array} objects Objects to collect properties from.\n       *\n       * Returns an array of property names (array will be empty,\n       * if objects have no own properties).\n       */\n      collectPropertyNames: function (objects) {\n\n        var o, propName, props = [];\n        for (o in objects) {\n          for (propName in objects[o]) {\n            if ((objects[o].hasOwnProperty(propName)) &&\n                (props.indexOf(propName) < 0) && \n                (typeof objects[o][propName] !== 'function')) {\n\n              props.push(propName);\n            }\n          }\n        }\n        return props;\n      }\n    },\n\n    /**\n     * $.csv.toArray(csv)\n     * Converts a CSV entry string to a javascript array.\n     *\n     * @param {Array} csv The string containing the CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with simple CSV strings only. It's useful if you only\n     * need to parse a single entry. If you need to parse more than one line,\n     * use $.csv2Array instead.\n     */\n    toArray: function(csv, options, callback) {\n      options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      var state = (options.state !== undefined ? options.state : {});\n\n      // setup\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        state: state\n      };\n\n      var entry = $.csv.parsers.parseEntry(csv, options);\n\n      // push the value to a callback if one is defined\n      if(!config.callback) {\n        return entry;\n      } else {\n        config.callback('', entry);\n      }\n    },\n\n    /**\n     * $.csv.toArrays(csv)\n     * Converts a CSV string to a javascript array.\n     *\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with multi-line CSV. The breakdown is simple. The first\n     * dimension of the array represents the line (or entry/row) while the second\n     * dimension contains the values (or values/columns).\n     */\n    toArrays: function(csv, options, callback) {\n      options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n\n      // setup\n      var data = [];\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        }\n      };\n\n      // onPreParse hook\n      if(options.onPreParse !== undefined) {\n        options.onPreParse(csv, options.state);\n      }\n\n      // parse the data\n      data = $.csv.parsers.parse(csv, options);\n\n      // onPostParse hook\n      if(options.onPostParse !== undefined) {\n        options.onPostParse(data, options.state);\n      }\n\n      // push the value to a callback if one is defined\n      if(!config.callback) {\n        return data;\n      } else {\n        config.callback('', data);\n      }\n    },\n\n    /**\n     * $.csv.toObjects(csv)\n     * Converts a CSV string to a javascript object.\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     * @param {Boolean} [headers] Indicates whether the data contains a header line. Defaults to true.\n     *\n     * This method deals with multi-line CSV strings. Where the headers line is\n     * used as the key for each value per entry.\n     */\n    toObjects: function(csv, options, callback) {\n      options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\n      options.start = 'start' in options ? options.start : 1;\n      \n      // account for headers\n      if(config.headers) {\n        options.start++;\n      }\n      if(options.end && config.headers) {\n        options.end++;\n      }\n\n      // setup\n      var lines = [];\n      var data = [];\n\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        },\n        match: false,\n        transform: options.transform\n      };\n\n      // fetch the headers\n      var headerOptions = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        start: 1,\n        end: 1,\n        state: {\n          rowNum:1,\n          colNum:1\n        }\n      };\n\n      // onPreParse hook\n      if(options.onPreParse !== undefined) {\n        options.onPreParse(csv, options.state);\n      }\n\n      // parse the csv\n      var headerLine = $.csv.parsers.splitLines(csv, headerOptions);\n      var headers = $.csv.toArray(headerLine[0], options);\n\n      // fetch the data\n      lines = $.csv.parsers.splitLines(csv, options);\n\n      // reset the state for re-use\n      options.state.colNum = 1;\n      if(headers){\n        options.state.rowNum = 2;\n      } else {\n        options.state.rowNum = 1;\n      }\n      \n      // convert data to objects\n      for(var i=0, len=lines.length; i<len; i++) {\n        var entry = $.csv.toArray(lines[i], options);\n        var object = {};\n        for(var j=0; j <headers.length; j++) {\n          object[headers[j]] = entry[j];\n        }\n        if (options.transform !== undefined) {\n          data.push(options.transform.call(undefined, object));\n        } else {\n          data.push(object);\n        }\n        \n        // update row state\n        options.state.rowNum++;\n      }\n\n      // onPostParse hook\n      if(options.onPostParse !== undefined) {\n        options.onPostParse(data, options.state);\n      }\n\n      // push the value to a callback if one is defined\n      if(!config.callback) {\n        return data;\n      } else {\n        config.callback('', data);\n      }\n    },\n\n     /**\n     * $.csv.fromArrays(arrays)\n     * Converts a javascript array to a CSV String.\n     *\n     * @param {Array} arrays An array containing an array of CSV entries.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method generates a CSV file from an array of arrays (representing entries).\n     */\n    fromArrays: function(arrays, options, callback) {\n      options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n\n      var output = '',\n          line,\n          lineValues,\n          i, j;\n\n      for (i = 0; i < arrays.length; i++) {\n        line = arrays[i];\n        lineValues = [];\n        for (j = 0; j < line.length; j++) {\n          var strValue = (line[j] === undefined || line[j] === null) ? '' : line[j].toString();\n          if (strValue.indexOf(config.delimiter) > -1) {\n            strValue = strValue.replace(new RegExp(config.delimiter, 'g'), config.delimiter + config.delimiter);\n          }\n\n          var escMatcher = '\\n|\\r|S|D';\n          escMatcher = escMatcher.replace('S', config.separator);\n          escMatcher = escMatcher.replace('D', config.delimiter);\n\n          if (strValue.search(escMatcher) > -1) {\n            strValue = config.delimiter + strValue + config.delimiter;\n          }\n          lineValues.push(strValue);\n        }\n        output += lineValues.join(config.separator) + '\\r\\n';\n      }\n\n      // push the value to a callback if one is defined\n      if(!config.callback) {\n        return output;\n      } else {\n        config.callback('', output);\n      }\n    },\n\n    /**\n     * $.csv.fromObjects(objects)\n     * Converts a javascript dictionary to a CSV string.\n     *\n     * @param {Object} objects An array of objects containing the data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     * @param {Character} [sortOrder] Sort order of columns (named after\n     *   object properties). Use 'alpha' for alphabetic. Default is 'declare',\n     *   which means, that properties will _probably_ appear in order they were\n     *   declared for the object. But without any guarantee.\n     * @param {Character or Array} [manualOrder] Manually order columns. May be\n     * a strin in a same csv format as an output or an array of header names\n     * (array items won't be parsed). All the properties, not present in\n     * `manualOrder` will be appended to the end in accordance with `sortOrder`\n     * option. So the `manualOrder` always takes preference, if present.\n     *\n     * This method generates a CSV file from an array of objects (name:value pairs).\n     * It starts by detecting the headers and adding them as the first line of\n     * the CSV file, followed by a structured dump of the data.\n     */\n    fromObjects: function(objects, options, callback) {\n      options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\n      config.sortOrder = 'sortOrder' in options ? options.sortOrder : 'declare';\n      config.manualOrder = 'manualOrder' in options ? options.manualOrder : [];\n      config.transform = options.transform;\n\n      if (typeof config.manualOrder === 'string') {\n        config.manualOrder = $.csv.toArray(config.manualOrder, config);\n      }\n\n      if (config.transform !== undefined) {\n        var origObjects = objects;\n        objects = [];\n\n        var i;\n        for (i = 0; i < origObjects.length; i++) {\n          objects.push(config.transform.call(undefined, origObjects[i]));\n        }\n      }\n\n      var props = $.csv.helpers.collectPropertyNames(objects);\n\n      if (config.sortOrder === 'alpha') {\n        props.sort();\n      } // else {} - nothing to do for 'declare' order\n\n      if (config.manualOrder.length > 0) {\n\n        var propsManual = [].concat(config.manualOrder);\n        var p;\n        for (p = 0; p < props.length; p++) {\n          if (propsManual.indexOf( props[p] ) < 0) {\n            propsManual.push( props[p] );\n          }\n        }\n        props = propsManual;\n      }\n\n      var o, p, line, output = [], propName;\n      if (config.headers) {\n        output.push(props);\n      }\n\n      for (o = 0; o < objects.length; o++) {\n        line = [];\n        for (p = 0; p < props.length; p++) {\n          propName = props[p];\n          if (propName in objects[o] && typeof objects[o][propName] !== 'function') {\n            line.push(objects[o][propName]);\n          } else {\n            line.push('');\n          }\n        }\n        output.push(line);\n      }\n\n      // push the value to a callback if one is defined\n      return $.csv.fromArrays(output, options, config.callback);\n    }\n  };\n\n  // Maintenance code to maintain backward-compatibility\n  // Will be removed in release 1.0\n  $.csvEntry2Array = $.csv.toArray;\n  $.csv2Array = $.csv.toArrays;\n  $.csv2Dictionary = $.csv.toObjects;\n\n  // CommonJS module is defined\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = $.csv;\n  }\n\n}).call( this );\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\nrequire('jquery-csv');\n\nvar APP_LINK = 'https://docs.google.com/forms/d/e/1FAIpQLSf9TdDeKUVQ_mQtjfJM3fgEwt62luhGCsvRoiebx427F9ZO2Q/viewform?entry.568591555=';\n\nvar input = document.getElementById('input-school');\nvar select = document.getElementById('select-school');\nvar button = document.getElementById('button-form');\n\n$.get('./public/files/schools.csv', function (data) {\n\tvar schools = [];\n\tvar csv = $.csv.toArrays(data);\n\tcsv.forEach(function (row) {\n\t\tvar school = row[0];\n\t\tschools.push(school);\n\t\tvar option = document.createElement('option');\n\t\toption.setAttribute('value', school);\n\t\toption.innerText = school;\n\t\tselect.appendChild(option);\n\t});\n\n\tbutton.removeAttribute('disabled');\n\tbutton.addEventListener('click', function (e) {\n\t\tvar yourSchool = select.value;\n\t\tconsole.log(yourSchool);\n\t\twindow.location = '' + APP_LINK + yourSchool;\n\t});\n});\n\n},{\"jquery-csv\":1}]},{},[2])\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5LWNzdi9zcmMvanF1ZXJ5LmNzdi5qcyIsInNyYy9qcy9hcHBseS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDLzhCQSxRQUFRLFlBQVI7O0FBRUEsSUFBTSxpSUFBTjs7QUFFQSxJQUFJLFFBQVEsU0FBUyxjQUFULENBQXdCLGNBQXhCLENBQVo7QUFDQSxJQUFJLFNBQVMsU0FBUyxjQUFULENBQXdCLGVBQXhCLENBQWI7QUFDQSxJQUFJLFNBQVMsU0FBUyxjQUFULENBQXdCLGFBQXhCLENBQWI7O0FBRUEsRUFBRSxHQUFGLENBQU0sNEJBQU4sRUFBb0MsVUFBQyxJQUFELEVBQVU7QUFDN0MsS0FBSSxVQUFVLEVBQWQ7QUFDQSxLQUFJLE1BQU0sRUFBRSxHQUFGLENBQU0sUUFBTixDQUFlLElBQWYsQ0FBVjtBQUNBLEtBQUksT0FBSixDQUFZLFVBQUMsR0FBRCxFQUFTO0FBQ3BCLE1BQUksU0FBUyxJQUFJLENBQUosQ0FBYjtBQUNBLFVBQVEsSUFBUixDQUFhLE1BQWI7QUFDQSxNQUFJLFNBQVMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBQWI7QUFDQyxTQUFPLFlBQVAsQ0FBb0IsT0FBcEIsRUFBNkIsTUFBN0I7QUFDQSxTQUFPLFNBQVAsR0FBbUIsTUFBbkI7QUFDQSxTQUFPLFdBQVAsQ0FBbUIsTUFBbkI7QUFDRCxFQVBEOztBQVNBLFFBQU8sZUFBUCxDQUF1QixVQUF2QjtBQUNBLFFBQU8sZ0JBQVAsQ0FBd0IsT0FBeEIsRUFBaUMsVUFBQyxDQUFELEVBQU87QUFDdkMsTUFBSSxhQUFhLE9BQU8sS0FBeEI7QUFDQSxVQUFRLEdBQVIsQ0FBWSxVQUFaO0FBQ0EsU0FBTyxRQUFQLFFBQXFCLFFBQXJCLEdBQWdDLFVBQWhDO0FBQ0EsRUFKRDtBQU1BLENBbkJEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogalF1ZXJ5LWNzdiAoalF1ZXJ5IFBsdWdpbilcbiAqXG4gKiBUaGlzIGRvY3VtZW50IGlzIGxpY2Vuc2VkIGFzIGZyZWUgc29mdHdhcmUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZVxuICogTUlUIExpY2Vuc2U6IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogQWNrbm93bGVkZ2VtZW50czpcbiAqIFRoZSBvcmlnaW5hbCBkZXNpZ24gYW5kIGluZmx1ZW5jZSB0byBpbXBsZW1lbnQgdGhpcyBsaWJyYXJ5IGFzIGEganF1ZXJ5XG4gKiBwbHVnaW4gaXMgaW5mbHVlbmNlZCBieSBqcXVlcnktanNvbiAoaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS1qc29uLykuXG4gKiBJZiB5b3UncmUgbG9va2luZyB0byB1c2UgbmF0aXZlIEpTT04uU3RyaW5naWZ5IGJ1dCB3YW50IGFkZGl0aW9uYWwgYmFja3dhcmRzXG4gKiBjb21wYXRpYmlsaXR5IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXQsIEkgaGlnaGx5IHJlY29tbWVuZCB5b3VcbiAqIGNoZWNrIGl0IG91dC5cbiAqXG4gKiBBIHNwZWNpYWwgdGhhbmtzIGdvZXMgb3V0IHRvIHJ3a0BhY20ub3JnIGZvciBwcm92aWRpbmcgYSBsb3Qgb2YgdmFsdWFibGVcbiAqIGZlZWRiYWNrIHRvIHRoZSBwcm9qZWN0IGluY2x1ZGluZyB0aGUgY29yZSBmb3IgdGhlIG5ldyBGU01cbiAqIChGaW5pdGUgU3RhdGUgTWFjaGluZSkgcGFyc2Vycy4gSWYgeW91J3JlIGxvb2tpbmcgZm9yIGEgc3RhYmxlIFRTViBwYXJzZXJcbiAqIGJlIHN1cmUgdG8gdGFrZSBhIGxvb2sgYXQganF1ZXJ5LXRzdiAoaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS10c3YvKS5cblxuICogRm9yIGxlZ2FsIHB1cnBvc2VzIEknbGwgaW5jbHVkZSB0aGUgXCJOTyBXQVJSQU5UWSBFWFBSRVNTRUQgT1IgSU1QTElFRC5cbiAqIFVTRSBBVCBZT1VSIE9XTiBSSVNLLlwiLiBXaGljaCwgaW4gJ2xheW1hbidzIHRlcm1zJyBtZWFucywgYnkgdXNpbmcgdGhpc1xuICogbGlicmFyeSB5b3UgYXJlIGFjY2VwdGluZyByZXNwb25zaWJpbGl0eSBpZiBpdCBicmVha3MgeW91ciBjb2RlLlxuICpcbiAqIExlZ2FsIGphcmdvbiBhc2lkZSwgSSB3aWxsIGRvIG15IGJlc3QgdG8gcHJvdmlkZSBhIHVzZWZ1bCBhbmQgc3RhYmxlIGNvcmVcbiAqIHRoYXQgY2FuIGVmZmVjdGl2ZWx5IGJlIGJ1aWx0IG9uLlxuICpcbiAqIENvcHlyaWdodGVkIDIwMTIgYnkgRXZhbiBQbGFpY2UuXG4gKi9cblxuUmVnRXhwLmVzY2FwZT0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xufTtcblxuKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciAkO1xuXG4gIC8vIHRvIGtlZXAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgaWYgKHR5cGVvZiBqUXVlcnkgIT09ICd1bmRlZmluZWQnICYmIGpRdWVyeSkge1xuICAgICQgPSBqUXVlcnk7XG4gIH0gZWxzZSB7XG4gICAgJCA9IHt9O1xuICB9XG5cblxuICAvKipcbiAgICogalF1ZXJ5LmNzdi5kZWZhdWx0c1xuICAgKiBFbmNhcHN1bGF0ZXMgdGhlIG1ldGhvZCBwYXJhbWF0ZXIgZGVmYXVsdHMgZm9yIHRoZSBDU1YgcGx1Z2luIG1vZHVsZS5cbiAgICovXG5cbiAgJC5jc3YgPSB7XG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIHNlcGFyYXRvcjonLCcsXG4gICAgICBkZWxpbWl0ZXI6J1wiJyxcbiAgICAgIGhlYWRlcnM6dHJ1ZVxuICAgIH0sXG5cbiAgICBob29rczoge1xuICAgICAgY2FzdFRvU2NhbGFyOiBmdW5jdGlvbih2YWx1ZSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGhhc0RvdCA9IC9cXC4vO1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChoYXNEb3QudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGludGVnZXIgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICBpZihpc05hTihpbnRlZ2VyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnRlZ2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZXJzOiB7XG4gICAgICBwYXJzZTogZnVuY3Rpb24oY3N2LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGNhY2hlIHNldHRpbmdzXG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvcjtcbiAgICAgICAgdmFyIGRlbGltaXRlciA9IG9wdGlvbnMuZGVsaW1pdGVyO1xuXG4gICAgICAgIC8vIHNldCBpbml0aWFsIHN0YXRlIGlmIGl0J3MgbWlzc2luZ1xuICAgICAgICBpZighb3B0aW9ucy5zdGF0ZS5yb3dOdW0pIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXRlLnJvd051bSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIW9wdGlvbnMuc3RhdGUuY29sTnVtKSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGF0ZS5jb2xOdW0gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgaW5pdGlhbCBzdGF0ZVxuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICB2YXIgZW50cnkgPSBbXTtcbiAgICAgICAgdmFyIHN0YXRlID0gMDtcbiAgICAgICAgdmFyIHZhbHVlID0gJyc7XG4gICAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gZW5kT2ZFbnRyeSgpIHtcbiAgICAgICAgICAvLyByZXNldCB0aGUgc3RhdGVcbiAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgdmFsdWUgPSAnJztcblxuICAgICAgICAgIC8vIGlmICdzdGFydCcgaGFzbid0IGJlZW4gbWV0LCBkb24ndCBvdXRwdXRcbiAgICAgICAgICBpZihvcHRpb25zLnN0YXJ0ICYmIG9wdGlvbnMuc3RhdGUucm93TnVtIDwgb3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGdsb2JhbCBzdGF0ZVxuICAgICAgICAgICAgZW50cnkgPSBbXTtcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtKys7XG4gICAgICAgICAgICBvcHRpb25zLnN0YXRlLmNvbE51bSA9IDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKG9wdGlvbnMub25QYXJzZUVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG9uUGFyc2VFbnRyeSBob29rIG5vdCBzZXRcbiAgICAgICAgICAgIGRhdGEucHVzaChlbnRyeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBob29rVmFsID0gb3B0aW9ucy5vblBhcnNlRW50cnkoZW50cnksIG9wdGlvbnMuc3RhdGUpOyAvLyBvblBhcnNlRW50cnkgSG9va1xuICAgICAgICAgICAgLy8gZmFsc2Ugc2tpcHMgdGhlIHJvdywgY29uZmlndXJhYmxlIHRocm91Z2ggYSBob29rXG4gICAgICAgICAgICBpZihob29rVmFsICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBkYXRhLnB1c2goaG9va1ZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2VudHJ5OicgKyBlbnRyeSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gY2xlYW51cFxuICAgICAgICAgIGVudHJ5ID0gW107XG5cbiAgICAgICAgICAvLyBpZiAnZW5kJyBpcyBtZXQsIHN0b3AgcGFyc2luZ1xuICAgICAgICAgIGlmKG9wdGlvbnMuZW5kICYmIG9wdGlvbnMuc3RhdGUucm93TnVtID49IG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gdXBkYXRlIGdsb2JhbCBzdGF0ZVxuICAgICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtKys7XG4gICAgICAgICAgb3B0aW9ucy5zdGF0ZS5jb2xOdW0gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZW5kT2ZWYWx1ZSgpIHtcbiAgICAgICAgICBpZihvcHRpb25zLm9uUGFyc2VWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBvblBhcnNlVmFsdWUgaG9vayBub3Qgc2V0XG4gICAgICAgICAgICBlbnRyeS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhvb2sgPSBvcHRpb25zLm9uUGFyc2VWYWx1ZSh2YWx1ZSwgb3B0aW9ucy5zdGF0ZSk7IC8vIG9uUGFyc2VWYWx1ZSBIb29rXG4gICAgICAgICAgICAvLyBmYWxzZSBza2lwcyB0aGUgcm93LCBjb25maWd1cmFibGUgdGhyb3VnaCBhIGhvb2tcbiAgICAgICAgICAgIGlmKGhvb2sgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGVudHJ5LnB1c2goaG9vayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ZhbHVlOicgKyB2YWx1ZSk7XG4gICAgICAgICAgLy8gcmVzZXQgdGhlIHN0YXRlXG4gICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgLy8gdXBkYXRlIGdsb2JhbCBzdGF0ZVxuICAgICAgICAgIG9wdGlvbnMuc3RhdGUuY29sTnVtKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlc2NhcGUgcmVnZXgtc3BlY2lmaWMgY29udHJvbCBjaGFyc1xuICAgICAgICB2YXIgZXNjU2VwYXJhdG9yID0gUmVnRXhwLmVzY2FwZShzZXBhcmF0b3IpO1xuICAgICAgICB2YXIgZXNjRGVsaW1pdGVyID0gUmVnRXhwLmVzY2FwZShkZWxpbWl0ZXIpO1xuXG4gICAgICAgIC8vIGNvbXBpbGUgdGhlIHJlZ0V4IHN0ciB1c2luZyB0aGUgY3VzdG9tIGRlbGltaXRlci9zZXBhcmF0b3JcbiAgICAgICAgdmFyIG1hdGNoID0gLyhEfFN8XFxyXFxufFxcbnxcXHJ8W15EU1xcclxcbl0rKS87XG4gICAgICAgIHZhciBtYXRjaFNyYyA9IG1hdGNoLnNvdXJjZTtcbiAgICAgICAgbWF0Y2hTcmMgPSBtYXRjaFNyYy5yZXBsYWNlKC9TL2csIGVzY1NlcGFyYXRvcik7XG4gICAgICAgIG1hdGNoU3JjID0gbWF0Y2hTcmMucmVwbGFjZSgvRC9nLCBlc2NEZWxpbWl0ZXIpO1xuICAgICAgICBtYXRjaCA9IG5ldyBSZWdFeHAobWF0Y2hTcmMsICdnbScpO1xuXG4gICAgICAgIC8vIHB1dCBvbiB5b3VyIGZhbmN5IHBhbnRzLi4uXG4gICAgICAgIC8vIHByb2Nlc3MgY29udHJvbCBjaGFycyBpbmRpdmlkdWFsbHksIHVzZSBsb29rLWFoZWFkIG9uIG5vbi1jb250cm9sIGNoYXJzXG4gICAgICAgIGNzdi5yZXBsYWNlKG1hdGNoLCBmdW5jdGlvbiAobTApIHtcbiAgICAgICAgICBpZihleGl0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIC8vIHRoZSBzdGFydCBvZiBhIHZhbHVlXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIC8vIG51bGwgbGFzdCB2YWx1ZVxuICAgICAgICAgICAgICBpZiAobTAgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9ICcnO1xuICAgICAgICAgICAgICAgIGVuZE9mVmFsdWUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBvcGVuaW5nIGRlbGltaXRlclxuICAgICAgICAgICAgICBpZiAobTAgPT09IGRlbGltaXRlcikge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBudWxsIGxhc3QgdmFsdWVcbiAgICAgICAgICAgICAgaWYgKC9eKFxcclxcbnxcXG58XFxyKSQvLnRlc3QobTApKSB7XG4gICAgICAgICAgICAgICAgZW5kT2ZWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGVuZE9mRW50cnkoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyB1bi1kZWxpbWl0ZWQgdmFsdWVcbiAgICAgICAgICAgICAgdmFsdWUgKz0gbTA7XG4gICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIGRlbGltaXRlZCBpbnB1dFxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAvLyBzZWNvbmQgZGVsaW1pdGVyPyBjaGVjayBmdXJ0aGVyXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGRlbGltaXRlZCBkYXRhXG4gICAgICAgICAgICAgIHZhbHVlICs9IG0wO1xuICAgICAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBkZWxpbWl0ZXIgZm91bmQgaW4gZGVsaW1pdGVkIGlucHV0XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIC8vIGVzY2FwZWQgZGVsaW1pdGVyP1xuICAgICAgICAgICAgICBpZiAobTAgPT09IGRlbGltaXRlcikge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IG0wO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBudWxsIHZhbHVlXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgZW5kT2ZWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGVuZCBvZiBlbnRyeVxuICAgICAgICAgICAgICBpZiAoL14oXFxyXFxufFxcbnxcXHIpJC8udGVzdChtMCkpIHtcbiAgICAgICAgICAgICAgICBlbmRPZlZhbHVlKCk7XG4gICAgICAgICAgICAgICAgZW5kT2ZFbnRyeSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBwYXNlcj9cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1ZEYXRhRXJyb3I6IElsbGVnYWwgU3RhdGUgW1JvdzonICsgb3B0aW9ucy5zdGF0ZS5yb3dOdW0gKyAnXVtDb2w6JyArIG9wdGlvbnMuc3RhdGUuY29sTnVtICsgJ10nKTtcblxuICAgICAgICAgICAgLy8gdW4tZGVsaW1pdGVkIGlucHV0XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIC8vIG51bGwgbGFzdCB2YWx1ZVxuICAgICAgICAgICAgICBpZiAobTAgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGVuZE9mVmFsdWUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBlbmQgb2YgZW50cnlcbiAgICAgICAgICAgICAgaWYgKC9eKFxcclxcbnxcXG58XFxyKSQvLnRlc3QobTApKSB7XG4gICAgICAgICAgICAgICAgZW5kT2ZWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGVuZE9mRW50cnkoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobTAgPT09IGRlbGltaXRlcikge1xuICAgICAgICAgICAgICAvLyBub24tY29tcGxpYW50IGRhdGFcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTVkRhdGFFcnJvcjogSWxsZWdhbCBRdW90ZSBbUm93OicgKyBvcHRpb25zLnN0YXRlLnJvd051bSArICddW0NvbDonICsgb3B0aW9ucy5zdGF0ZS5jb2xOdW0gKyAnXScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBwYXJzZXI/XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ1NWRGF0YUVycm9yOiBJbGxlZ2FsIERhdGEgW1JvdzonICsgb3B0aW9ucy5zdGF0ZS5yb3dOdW0gKyAnXVtDb2w6JyArIG9wdGlvbnMuc3RhdGUuY29sTnVtICsgJ10nKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNoZW5hbmlnYW5zXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ1NWRGF0YUVycm9yOiBVbmtub3duIFN0YXRlIFtSb3c6JyArIG9wdGlvbnMuc3RhdGUucm93TnVtICsgJ11bQ29sOicgKyBvcHRpb25zLnN0YXRlLmNvbE51bSArICddJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ZhbDonICsgbTAgKyAnIHN0YXRlOicgKyBzdGF0ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN1Ym1pdCB0aGUgbGFzdCBlbnRyeVxuICAgICAgICAvLyBpZ25vcmUgbnVsbCBsYXN0IGxpbmVcbiAgICAgICAgaWYoZW50cnkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgZW5kT2ZWYWx1ZSgpO1xuICAgICAgICAgIGVuZE9mRW50cnkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSxcblxuICAgICAgLy8gYSBjc3Ytc3BlY2lmaWMgbGluZSBzcGxpdHRlclxuICAgICAgc3BsaXRMaW5lczogZnVuY3Rpb24oY3N2LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGNhY2hlIHNldHRpbmdzXG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvcjtcbiAgICAgICAgdmFyIGRlbGltaXRlciA9IG9wdGlvbnMuZGVsaW1pdGVyO1xuXG4gICAgICAgIC8vIHNldCBpbml0aWFsIHN0YXRlIGlmIGl0J3MgbWlzc2luZ1xuICAgICAgICBpZighb3B0aW9ucy5zdGF0ZS5yb3dOdW0pIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXRlLnJvd051bSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBpbml0aWFsIHN0YXRlXG4gICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgIHZhciBzdGF0ZSA9IDA7XG4gICAgICAgIHZhciBlbnRyeSA9ICcnO1xuICAgICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVuZE9mTGluZSgpIHsgICAgICAgICAgXG4gICAgICAgICAgLy8gcmVzZXQgdGhlIHN0YXRlXG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIGlmICdzdGFydCcgaGFzbid0IGJlZW4gbWV0LCBkb24ndCBvdXRwdXRcbiAgICAgICAgICBpZihvcHRpb25zLnN0YXJ0ICYmIG9wdGlvbnMuc3RhdGUucm93TnVtIDwgb3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGdsb2JhbCBzdGF0ZVxuICAgICAgICAgICAgZW50cnkgPSAnJztcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtKys7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKG9wdGlvbnMub25QYXJzZUVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG9uUGFyc2VFbnRyeSBob29rIG5vdCBzZXRcbiAgICAgICAgICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBob29rVmFsID0gb3B0aW9ucy5vblBhcnNlRW50cnkoZW50cnksIG9wdGlvbnMuc3RhdGUpOyAvLyBvblBhcnNlRW50cnkgSG9va1xuICAgICAgICAgICAgLy8gZmFsc2Ugc2tpcHMgdGhlIHJvdywgY29uZmlndXJhYmxlIHRocm91Z2ggYSBob29rXG4gICAgICAgICAgICBpZihob29rVmFsICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goaG9va1ZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY2xlYW51cFxuICAgICAgICAgIGVudHJ5ID0gJyc7XG5cbiAgICAgICAgICAvLyBpZiAnZW5kJyBpcyBtZXQsIHN0b3AgcGFyc2luZ1xuICAgICAgICAgIGlmKG9wdGlvbnMuZW5kICYmIG9wdGlvbnMuc3RhdGUucm93TnVtID49IG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gdXBkYXRlIGdsb2JhbCBzdGF0ZVxuICAgICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlc2NhcGUgcmVnZXgtc3BlY2lmaWMgY29udHJvbCBjaGFyc1xuICAgICAgICB2YXIgZXNjU2VwYXJhdG9yID0gUmVnRXhwLmVzY2FwZShzZXBhcmF0b3IpO1xuICAgICAgICB2YXIgZXNjRGVsaW1pdGVyID0gUmVnRXhwLmVzY2FwZShkZWxpbWl0ZXIpO1xuXG4gICAgICAgIC8vIGNvbXBpbGUgdGhlIHJlZ0V4IHN0ciB1c2luZyB0aGUgY3VzdG9tIGRlbGltaXRlci9zZXBhcmF0b3JcbiAgICAgICAgdmFyIG1hdGNoID0gLyhEfFN8XFxufFxccnxbXkRTXFxyXFxuXSspLztcbiAgICAgICAgdmFyIG1hdGNoU3JjID0gbWF0Y2guc291cmNlO1xuICAgICAgICBtYXRjaFNyYyA9IG1hdGNoU3JjLnJlcGxhY2UoL1MvZywgZXNjU2VwYXJhdG9yKTtcbiAgICAgICAgbWF0Y2hTcmMgPSBtYXRjaFNyYy5yZXBsYWNlKC9EL2csIGVzY0RlbGltaXRlcik7XG4gICAgICAgIG1hdGNoID0gbmV3IFJlZ0V4cChtYXRjaFNyYywgJ2dtJyk7XG5cbiAgICAgICAgLy8gcHV0IG9uIHlvdXIgZmFuY3kgcGFudHMuLi5cbiAgICAgICAgLy8gcHJvY2VzcyBjb250cm9sIGNoYXJzIGluZGl2aWR1YWxseSwgdXNlIGxvb2stYWhlYWQgb24gbm9uLWNvbnRyb2wgY2hhcnNcbiAgICAgICAgY3N2LnJlcGxhY2UobWF0Y2gsIGZ1bmN0aW9uIChtMCkge1xuICAgICAgICAgIGlmKGV4aXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgLy8gdGhlIHN0YXJ0IG9mIGEgdmFsdWUvZW50cnlcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgLy8gbnVsbCB2YWx1ZVxuICAgICAgICAgICAgICBpZiAobTAgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGVudHJ5ICs9IG0wO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBvcGVuaW5nIGRlbGltaXRlclxuICAgICAgICAgICAgICBpZiAobTAgPT09IGRlbGltaXRlcikge1xuICAgICAgICAgICAgICAgIGVudHJ5ICs9IG0wO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBlbmQgb2YgbGluZVxuICAgICAgICAgICAgICBpZiAobTAgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgZW5kT2ZMaW5lKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gcGhhbnRvbSBjYXJyaWFnZSByZXR1cm5cbiAgICAgICAgICAgICAgaWYgKC9eXFxyJC8udGVzdChtMCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyB1bi1kZWxpbWl0IHZhbHVlXG4gICAgICAgICAgICAgIGVudHJ5ICs9IG0wO1xuICAgICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBkZWxpbWl0ZWQgaW5wdXRcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgLy8gc2Vjb25kIGRlbGltaXRlcj8gY2hlY2sgZnVydGhlclxuICAgICAgICAgICAgICBpZiAobTAgPT09IGRlbGltaXRlcikge1xuICAgICAgICAgICAgICAgIGVudHJ5ICs9IG0wO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBkZWxpbWl0ZWQgZGF0YVxuICAgICAgICAgICAgICBlbnRyeSArPSBtMDtcbiAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gZGVsaW1pdGVyIGZvdW5kIGluIGRlbGltaXRlZCBpbnB1dFxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAvLyBlc2NhcGVkIGRlbGltaXRlcj9cbiAgICAgICAgICAgICAgdmFyIHByZXZDaGFyID0gZW50cnkuc3Vic3RyKGVudHJ5Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICBpZiAobTAgPT09IGRlbGltaXRlciAmJiBwcmV2Q2hhciA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgZW50cnkgKz0gbTA7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGVuZCBvZiB2YWx1ZVxuICAgICAgICAgICAgICBpZiAobTAgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGVudHJ5ICs9IG0wO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBlbmQgb2YgbGluZVxuICAgICAgICAgICAgICBpZiAobTAgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgZW5kT2ZMaW5lKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gcGhhbnRvbSBjYXJyaWFnZSByZXR1cm5cbiAgICAgICAgICAgICAgaWYgKG0wID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBwYXNlcj9cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1ZEYXRhRXJyb3I6IElsbGVnYWwgc3RhdGUgW1JvdzonICsgb3B0aW9ucy5zdGF0ZS5yb3dOdW0gKyAnXScpO1xuXG4gICAgICAgICAgICAvLyB1bi1kZWxpbWl0ZWQgaW5wdXRcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgLy8gbnVsbCB2YWx1ZVxuICAgICAgICAgICAgICBpZiAobTAgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGVudHJ5ICs9IG0wO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBlbmQgb2YgbGluZVxuICAgICAgICAgICAgICBpZiAobTAgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgZW5kT2ZMaW5lKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gcGhhbnRvbSBjYXJyaWFnZSByZXR1cm5cbiAgICAgICAgICAgICAgaWYgKG0wID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG5vbi1jb21wbGlhbnQgZGF0YVxuICAgICAgICAgICAgICBpZiAobTAgPT09IGRlbGltaXRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ1NWRGF0YUVycm9yOiBJbGxlZ2FsIHF1b3RlIFtSb3c6JyArIG9wdGlvbnMuc3RhdGUucm93TnVtICsgJ10nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBicm9rZW4gcGFyc2VyP1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTVkRhdGFFcnJvcjogSWxsZWdhbCBzdGF0ZSBbUm93OicgKyBvcHRpb25zLnN0YXRlLnJvd051bSArICddJyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzaGVuYW5pZ2Fuc1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTVkRhdGFFcnJvcjogVW5rbm93biBzdGF0ZSBbUm93OicgKyBvcHRpb25zLnN0YXRlLnJvd051bSArICddJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ZhbDonICsgbTAgKyAnIHN0YXRlOicgKyBzdGF0ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN1Ym1pdCB0aGUgbGFzdCBlbnRyeVxuICAgICAgICAvLyBpZ25vcmUgbnVsbCBsYXN0IGxpbmVcbiAgICAgICAgaWYoZW50cnkgIT09ICcnKSB7XG4gICAgICAgICAgZW5kT2ZMaW5lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgIH0sXG5cbiAgICAgIC8vIGEgY3N2IGVudHJ5IHBhcnNlclxuICAgICAgcGFyc2VFbnRyeTogZnVuY3Rpb24oY3N2LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGNhY2hlIHNldHRpbmdzXG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvcjtcbiAgICAgICAgdmFyIGRlbGltaXRlciA9IG9wdGlvbnMuZGVsaW1pdGVyO1xuICAgICAgICBcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgc3RhdGUgaWYgaXQncyBtaXNzaW5nXG4gICAgICAgIGlmKCFvcHRpb25zLnN0YXRlLnJvd051bSkge1xuICAgICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZighb3B0aW9ucy5zdGF0ZS5jb2xOdW0pIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXRlLmNvbE51bSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBpbml0aWFsIHN0YXRlXG4gICAgICAgIHZhciBlbnRyeSA9IFtdO1xuICAgICAgICB2YXIgc3RhdGUgPSAwO1xuICAgICAgICB2YXIgdmFsdWUgPSAnJztcblxuICAgICAgICBmdW5jdGlvbiBlbmRPZlZhbHVlKCkge1xuICAgICAgICAgIGlmKG9wdGlvbnMub25QYXJzZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG9uUGFyc2VWYWx1ZSBob29rIG5vdCBzZXRcbiAgICAgICAgICAgIGVudHJ5LnB1c2godmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG9vayA9IG9wdGlvbnMub25QYXJzZVZhbHVlKHZhbHVlLCBvcHRpb25zLnN0YXRlKTsgLy8gb25QYXJzZVZhbHVlIEhvb2tcbiAgICAgICAgICAgIC8vIGZhbHNlIHNraXBzIHRoZSB2YWx1ZSwgY29uZmlndXJhYmxlIHRocm91Z2ggYSBob29rXG4gICAgICAgICAgICBpZihob29rICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBlbnRyeS5wdXNoKGhvb2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZXNldCB0aGUgc3RhdGVcbiAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAvLyB1cGRhdGUgZ2xvYmFsIHN0YXRlXG4gICAgICAgICAgb3B0aW9ucy5zdGF0ZS5jb2xOdW0rKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrZWQgZm9yIGEgY2FjaGVkIHJlZ0V4IGZpcnN0XG4gICAgICAgIGlmKCFvcHRpb25zLm1hdGNoKSB7XG4gICAgICAgICAgLy8gZXNjYXBlIHJlZ2V4LXNwZWNpZmljIGNvbnRyb2wgY2hhcnNcbiAgICAgICAgICB2YXIgZXNjU2VwYXJhdG9yID0gUmVnRXhwLmVzY2FwZShzZXBhcmF0b3IpO1xuICAgICAgICAgIHZhciBlc2NEZWxpbWl0ZXIgPSBSZWdFeHAuZXNjYXBlKGRlbGltaXRlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gY29tcGlsZSB0aGUgcmVnRXggc3RyIHVzaW5nIHRoZSBjdXN0b20gZGVsaW1pdGVyL3NlcGFyYXRvclxuICAgICAgICAgIHZhciBtYXRjaCA9IC8oRHxTfFxcbnxcXHJ8W15EU1xcclxcbl0rKS87XG4gICAgICAgICAgdmFyIG1hdGNoU3JjID0gbWF0Y2guc291cmNlO1xuICAgICAgICAgIG1hdGNoU3JjID0gbWF0Y2hTcmMucmVwbGFjZSgvUy9nLCBlc2NTZXBhcmF0b3IpO1xuICAgICAgICAgIG1hdGNoU3JjID0gbWF0Y2hTcmMucmVwbGFjZSgvRC9nLCBlc2NEZWxpbWl0ZXIpO1xuICAgICAgICAgIG9wdGlvbnMubWF0Y2ggPSBuZXcgUmVnRXhwKG1hdGNoU3JjLCAnZ20nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1dCBvbiB5b3VyIGZhbmN5IHBhbnRzLi4uXG4gICAgICAgIC8vIHByb2Nlc3MgY29udHJvbCBjaGFycyBpbmRpdmlkdWFsbHksIHVzZSBsb29rLWFoZWFkIG9uIG5vbi1jb250cm9sIGNoYXJzXG4gICAgICAgIGNzdi5yZXBsYWNlKG9wdGlvbnMubWF0Y2gsIGZ1bmN0aW9uIChtMCkge1xuICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIC8vIHRoZSBzdGFydCBvZiBhIHZhbHVlXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIC8vIG51bGwgbGFzdCB2YWx1ZVxuICAgICAgICAgICAgICBpZiAobTAgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9ICcnO1xuICAgICAgICAgICAgICAgIGVuZE9mVmFsdWUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBvcGVuaW5nIGRlbGltaXRlclxuICAgICAgICAgICAgICBpZiAobTAgPT09IGRlbGltaXRlcikge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBza2lwIHVuLWRlbGltaXRlZCBuZXctbGluZXNcbiAgICAgICAgICAgICAgaWYgKG0wID09PSAnXFxuJyB8fCBtMCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyB1bi1kZWxpbWl0ZWQgdmFsdWVcbiAgICAgICAgICAgICAgdmFsdWUgKz0gbTA7XG4gICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIGRlbGltaXRlZCBpbnB1dFxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAvLyBzZWNvbmQgZGVsaW1pdGVyPyBjaGVjayBmdXJ0aGVyXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGRlbGltaXRlZCBkYXRhXG4gICAgICAgICAgICAgIHZhbHVlICs9IG0wO1xuICAgICAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBkZWxpbWl0ZXIgZm91bmQgaW4gZGVsaW1pdGVkIGlucHV0XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIC8vIGVzY2FwZWQgZGVsaW1pdGVyP1xuICAgICAgICAgICAgICBpZiAobTAgPT09IGRlbGltaXRlcikge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IG0wO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBudWxsIHZhbHVlXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgZW5kT2ZWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHNraXAgdW4tZGVsaW1pdGVkIG5ldy1saW5lc1xuICAgICAgICAgICAgICBpZiAobTAgPT09ICdcXG4nIHx8IG0wID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBwYXNlcj9cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1ZEYXRhRXJyb3I6IElsbGVnYWwgU3RhdGUgW1JvdzonICsgb3B0aW9ucy5zdGF0ZS5yb3dOdW0gKyAnXVtDb2w6JyArIG9wdGlvbnMuc3RhdGUuY29sTnVtICsgJ10nKTtcblxuICAgICAgICAgICAgLy8gdW4tZGVsaW1pdGVkIGlucHV0XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIC8vIG51bGwgbGFzdCB2YWx1ZVxuICAgICAgICAgICAgICBpZiAobTAgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGVuZE9mVmFsdWUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBza2lwIHVuLWRlbGltaXRlZCBuZXctbGluZXNcbiAgICAgICAgICAgICAgaWYgKG0wID09PSAnXFxuJyB8fCBtMCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBub24tY29tcGxpYW50IGRhdGFcbiAgICAgICAgICAgICAgaWYgKG0wID09PSBkZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTVkRhdGFFcnJvcjogSWxsZWdhbCBRdW90ZSBbUm93OicgKyBvcHRpb25zLnN0YXRlLnJvd051bSArICddW0NvbDonICsgb3B0aW9ucy5zdGF0ZS5jb2xOdW0gKyAnXScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBwYXJzZXI/XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ1NWRGF0YUVycm9yOiBJbGxlZ2FsIERhdGEgW1JvdzonICsgb3B0aW9ucy5zdGF0ZS5yb3dOdW0gKyAnXVtDb2w6JyArIG9wdGlvbnMuc3RhdGUuY29sTnVtICsgJ10nKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNoZW5hbmlnYW5zXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ1NWRGF0YUVycm9yOiBVbmtub3duIFN0YXRlIFtSb3c6JyArIG9wdGlvbnMuc3RhdGUucm93TnVtICsgJ11bQ29sOicgKyBvcHRpb25zLnN0YXRlLmNvbE51bSArICddJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ZhbDonICsgbTAgKyAnIHN0YXRlOicgKyBzdGF0ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN1Ym1pdCB0aGUgbGFzdCB2YWx1ZVxuICAgICAgICBlbmRPZlZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoZWxwZXJzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogJC5jc3YuaGVscGVycy5jb2xsZWN0UHJvcGVydHlOYW1lcyhvYmplY3RzQXJyYXkpXG4gICAgICAgKiBDb2xsZWN0cyBhbGwgdW5pcXVlIHByb3BlcnR5IG5hbWVzIGZyb20gYWxsIHBhc3NlZCBvYmplY3RzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgT2JqZWN0cyB0byBjb2xsZWN0IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgICAqXG4gICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIChhcnJheSB3aWxsIGJlIGVtcHR5LFxuICAgICAgICogaWYgb2JqZWN0cyBoYXZlIG5vIG93biBwcm9wZXJ0aWVzKS5cbiAgICAgICAqL1xuICAgICAgY29sbGVjdFByb3BlcnR5TmFtZXM6IGZ1bmN0aW9uIChvYmplY3RzKSB7XG5cbiAgICAgICAgdmFyIG8sIHByb3BOYW1lLCBwcm9wcyA9IFtdO1xuICAgICAgICBmb3IgKG8gaW4gb2JqZWN0cykge1xuICAgICAgICAgIGZvciAocHJvcE5hbWUgaW4gb2JqZWN0c1tvXSkge1xuICAgICAgICAgICAgaWYgKChvYmplY3RzW29dLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkgJiZcbiAgICAgICAgICAgICAgICAocHJvcHMuaW5kZXhPZihwcm9wTmFtZSkgPCAwKSAmJiBcbiAgICAgICAgICAgICAgICAodHlwZW9mIG9iamVjdHNbb11bcHJvcE5hbWVdICE9PSAnZnVuY3Rpb24nKSkge1xuXG4gICAgICAgICAgICAgIHByb3BzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqICQuY3N2LnRvQXJyYXkoY3N2KVxuICAgICAqIENvbnZlcnRzIGEgQ1NWIGVudHJ5IHN0cmluZyB0byBhIGphdmFzY3JpcHQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjc3YgVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBDU1YgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHVzZXItZGVmaW5lZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7Q2hhcmFjdGVyfSBbc2VwYXJhdG9yXSBBbiBvdmVycmlkZSBmb3IgdGhlIHNlcGFyYXRvciBjaGFyYWN0ZXIuIERlZmF1bHRzIHRvIGEgY29tbWEoLCkuXG4gICAgICogQHBhcmFtIHtDaGFyYWN0ZXJ9IFtkZWxpbWl0ZXJdIEFuIG92ZXJyaWRlIGZvciB0aGUgZGVsaW1pdGVyIGNoYXJhY3Rlci4gRGVmYXVsdHMgdG8gYSBkb3VibGUtcXVvdGUoXCIpLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGVhbHMgd2l0aCBzaW1wbGUgQ1NWIHN0cmluZ3Mgb25seS4gSXQncyB1c2VmdWwgaWYgeW91IG9ubHlcbiAgICAgKiBuZWVkIHRvIHBhcnNlIGEgc2luZ2xlIGVudHJ5LiBJZiB5b3UgbmVlZCB0byBwYXJzZSBtb3JlIHRoYW4gb25lIGxpbmUsXG4gICAgICogdXNlICQuY3N2MkFycmF5IGluc3RlYWQuXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oY3N2LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgb3B0aW9ucyA9IChvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge30pO1xuICAgICAgdmFyIGNvbmZpZyA9IHt9O1xuICAgICAgY29uZmlnLmNhbGxiYWNrID0gKChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZihjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpID8gY2FsbGJhY2sgOiBmYWxzZSk7XG4gICAgICBjb25maWcuc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogJC5jc3YuZGVmYXVsdHMuc2VwYXJhdG9yO1xuICAgICAgY29uZmlnLmRlbGltaXRlciA9ICdkZWxpbWl0ZXInIGluIG9wdGlvbnMgPyBvcHRpb25zLmRlbGltaXRlciA6ICQuY3N2LmRlZmF1bHRzLmRlbGltaXRlcjtcbiAgICAgIHZhciBzdGF0ZSA9IChvcHRpb25zLnN0YXRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0YXRlIDoge30pO1xuXG4gICAgICAvLyBzZXR1cFxuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgZGVsaW1pdGVyOiBjb25maWcuZGVsaW1pdGVyLFxuICAgICAgICBzZXBhcmF0b3I6IGNvbmZpZy5zZXBhcmF0b3IsXG4gICAgICAgIG9uUGFyc2VFbnRyeTogb3B0aW9ucy5vblBhcnNlRW50cnksXG4gICAgICAgIG9uUGFyc2VWYWx1ZTogb3B0aW9ucy5vblBhcnNlVmFsdWUsXG4gICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgfTtcblxuICAgICAgdmFyIGVudHJ5ID0gJC5jc3YucGFyc2Vycy5wYXJzZUVudHJ5KGNzdiwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIHB1c2ggdGhlIHZhbHVlIHRvIGEgY2FsbGJhY2sgaWYgb25lIGlzIGRlZmluZWRcbiAgICAgIGlmKCFjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLmNhbGxiYWNrKCcnLCBlbnRyeSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqICQuY3N2LnRvQXJyYXlzKGNzdilcbiAgICAgKiBDb252ZXJ0cyBhIENTViBzdHJpbmcgdG8gYSBqYXZhc2NyaXB0IGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNzdiBUaGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHJhdyBDU1YgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHVzZXItZGVmaW5lZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7Q2hhcmFjdGVyfSBbc2VwYXJhdG9yXSBBbiBvdmVycmlkZSBmb3IgdGhlIHNlcGFyYXRvciBjaGFyYWN0ZXIuIERlZmF1bHRzIHRvIGEgY29tbWEoLCkuXG4gICAgICogQHBhcmFtIHtDaGFyYWN0ZXJ9IFtkZWxpbWl0ZXJdIEFuIG92ZXJyaWRlIGZvciB0aGUgZGVsaW1pdGVyIGNoYXJhY3Rlci4gRGVmYXVsdHMgdG8gYSBkb3VibGUtcXVvdGUoXCIpLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGVhbHMgd2l0aCBtdWx0aS1saW5lIENTVi4gVGhlIGJyZWFrZG93biBpcyBzaW1wbGUuIFRoZSBmaXJzdFxuICAgICAqIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgcmVwcmVzZW50cyB0aGUgbGluZSAob3IgZW50cnkvcm93KSB3aGlsZSB0aGUgc2Vjb25kXG4gICAgICogZGltZW5zaW9uIGNvbnRhaW5zIHRoZSB2YWx1ZXMgKG9yIHZhbHVlcy9jb2x1bW5zKS5cbiAgICAgKi9cbiAgICB0b0FycmF5czogZnVuY3Rpb24oY3N2LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgb3B0aW9ucyA9IChvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge30pO1xuICAgICAgdmFyIGNvbmZpZyA9IHt9O1xuICAgICAgY29uZmlnLmNhbGxiYWNrID0gKChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZihjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpID8gY2FsbGJhY2sgOiBmYWxzZSk7XG4gICAgICBjb25maWcuc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogJC5jc3YuZGVmYXVsdHMuc2VwYXJhdG9yO1xuICAgICAgY29uZmlnLmRlbGltaXRlciA9ICdkZWxpbWl0ZXInIGluIG9wdGlvbnMgPyBvcHRpb25zLmRlbGltaXRlciA6ICQuY3N2LmRlZmF1bHRzLmRlbGltaXRlcjtcblxuICAgICAgLy8gc2V0dXBcbiAgICAgIHZhciBkYXRhID0gW107XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBkZWxpbWl0ZXI6IGNvbmZpZy5kZWxpbWl0ZXIsXG4gICAgICAgIHNlcGFyYXRvcjogY29uZmlnLnNlcGFyYXRvcixcbiAgICAgICAgb25QcmVQYXJzZTogb3B0aW9ucy5vblByZVBhcnNlLFxuICAgICAgICBvblBhcnNlRW50cnk6IG9wdGlvbnMub25QYXJzZUVudHJ5LFxuICAgICAgICBvblBhcnNlVmFsdWU6IG9wdGlvbnMub25QYXJzZVZhbHVlLFxuICAgICAgICBvblBvc3RQYXJzZTogb3B0aW9ucy5vblBvc3RQYXJzZSxcbiAgICAgICAgc3RhcnQ6IG9wdGlvbnMuc3RhcnQsXG4gICAgICAgIGVuZDogb3B0aW9ucy5lbmQsXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgcm93TnVtOiAxLFxuICAgICAgICAgIGNvbE51bTogMVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBvblByZVBhcnNlIGhvb2tcbiAgICAgIGlmKG9wdGlvbnMub25QcmVQYXJzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMub25QcmVQYXJzZShjc3YsIG9wdGlvbnMuc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSB0aGUgZGF0YVxuICAgICAgZGF0YSA9ICQuY3N2LnBhcnNlcnMucGFyc2UoY3N2LCBvcHRpb25zKTtcblxuICAgICAgLy8gb25Qb3N0UGFyc2UgaG9va1xuICAgICAgaWYob3B0aW9ucy5vblBvc3RQYXJzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMub25Qb3N0UGFyc2UoZGF0YSwgb3B0aW9ucy5zdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHB1c2ggdGhlIHZhbHVlIHRvIGEgY2FsbGJhY2sgaWYgb25lIGlzIGRlZmluZWRcbiAgICAgIGlmKCFjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuY2FsbGJhY2soJycsIGRhdGEpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAkLmNzdi50b09iamVjdHMoY3N2KVxuICAgICAqIENvbnZlcnRzIGEgQ1NWIHN0cmluZyB0byBhIGphdmFzY3JpcHQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjc3YgVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSByYXcgQ1NWIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB1c2VyLWRlZmluZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0NoYXJhY3Rlcn0gW3NlcGFyYXRvcl0gQW4gb3ZlcnJpZGUgZm9yIHRoZSBzZXBhcmF0b3IgY2hhcmFjdGVyLiBEZWZhdWx0cyB0byBhIGNvbW1hKCwpLlxuICAgICAqIEBwYXJhbSB7Q2hhcmFjdGVyfSBbZGVsaW1pdGVyXSBBbiBvdmVycmlkZSBmb3IgdGhlIGRlbGltaXRlciBjaGFyYWN0ZXIuIERlZmF1bHRzIHRvIGEgZG91YmxlLXF1b3RlKFwiKS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtoZWFkZXJzXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0YSBjb250YWlucyBhIGhlYWRlciBsaW5lLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGVhbHMgd2l0aCBtdWx0aS1saW5lIENTViBzdHJpbmdzLiBXaGVyZSB0aGUgaGVhZGVycyBsaW5lIGlzXG4gICAgICogdXNlZCBhcyB0aGUga2V5IGZvciBlYWNoIHZhbHVlIHBlciBlbnRyeS5cbiAgICAgKi9cbiAgICB0b09iamVjdHM6IGZ1bmN0aW9uKGNzdiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIG9wdGlvbnMgPSAob3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucyA6IHt9KTtcbiAgICAgIHZhciBjb25maWcgPSB7fTtcbiAgICAgIGNvbmZpZy5jYWxsYmFjayA9ICgoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSA/IGNhbGxiYWNrIDogZmFsc2UpO1xuICAgICAgY29uZmlnLnNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6ICQuY3N2LmRlZmF1bHRzLnNlcGFyYXRvcjtcbiAgICAgIGNvbmZpZy5kZWxpbWl0ZXIgPSAnZGVsaW1pdGVyJyBpbiBvcHRpb25zID8gb3B0aW9ucy5kZWxpbWl0ZXIgOiAkLmNzdi5kZWZhdWx0cy5kZWxpbWl0ZXI7XG4gICAgICBjb25maWcuaGVhZGVycyA9ICdoZWFkZXJzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5oZWFkZXJzIDogJC5jc3YuZGVmYXVsdHMuaGVhZGVycztcbiAgICAgIG9wdGlvbnMuc3RhcnQgPSAnc3RhcnQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXJ0IDogMTtcbiAgICAgIFxuICAgICAgLy8gYWNjb3VudCBmb3IgaGVhZGVyc1xuICAgICAgaWYoY29uZmlnLmhlYWRlcnMpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCsrO1xuICAgICAgfVxuICAgICAgaWYob3B0aW9ucy5lbmQgJiYgY29uZmlnLmhlYWRlcnMpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQrKztcbiAgICAgIH1cblxuICAgICAgLy8gc2V0dXBcbiAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgdmFyIGRhdGEgPSBbXTtcblxuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgZGVsaW1pdGVyOiBjb25maWcuZGVsaW1pdGVyLFxuICAgICAgICBzZXBhcmF0b3I6IGNvbmZpZy5zZXBhcmF0b3IsXG4gICAgICAgIG9uUHJlUGFyc2U6IG9wdGlvbnMub25QcmVQYXJzZSxcbiAgICAgICAgb25QYXJzZUVudHJ5OiBvcHRpb25zLm9uUGFyc2VFbnRyeSxcbiAgICAgICAgb25QYXJzZVZhbHVlOiBvcHRpb25zLm9uUGFyc2VWYWx1ZSxcbiAgICAgICAgb25Qb3N0UGFyc2U6IG9wdGlvbnMub25Qb3N0UGFyc2UsXG4gICAgICAgIHN0YXJ0OiBvcHRpb25zLnN0YXJ0LFxuICAgICAgICBlbmQ6IG9wdGlvbnMuZW5kLFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgIHJvd051bTogMSxcbiAgICAgICAgICBjb2xOdW06IDFcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2g6IGZhbHNlLFxuICAgICAgICB0cmFuc2Zvcm06IG9wdGlvbnMudHJhbnNmb3JtXG4gICAgICB9O1xuXG4gICAgICAvLyBmZXRjaCB0aGUgaGVhZGVyc1xuICAgICAgdmFyIGhlYWRlck9wdGlvbnMgPSB7XG4gICAgICAgIGRlbGltaXRlcjogY29uZmlnLmRlbGltaXRlcixcbiAgICAgICAgc2VwYXJhdG9yOiBjb25maWcuc2VwYXJhdG9yLFxuICAgICAgICBzdGFydDogMSxcbiAgICAgICAgZW5kOiAxLFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgIHJvd051bToxLFxuICAgICAgICAgIGNvbE51bToxXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIG9uUHJlUGFyc2UgaG9va1xuICAgICAgaWYob3B0aW9ucy5vblByZVBhcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5vblByZVBhcnNlKGNzdiwgb3B0aW9ucy5zdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIHRoZSBjc3ZcbiAgICAgIHZhciBoZWFkZXJMaW5lID0gJC5jc3YucGFyc2Vycy5zcGxpdExpbmVzKGNzdiwgaGVhZGVyT3B0aW9ucyk7XG4gICAgICB2YXIgaGVhZGVycyA9ICQuY3N2LnRvQXJyYXkoaGVhZGVyTGluZVswXSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIGZldGNoIHRoZSBkYXRhXG4gICAgICBsaW5lcyA9ICQuY3N2LnBhcnNlcnMuc3BsaXRMaW5lcyhjc3YsIG9wdGlvbnMpO1xuXG4gICAgICAvLyByZXNldCB0aGUgc3RhdGUgZm9yIHJlLXVzZVxuICAgICAgb3B0aW9ucy5zdGF0ZS5jb2xOdW0gPSAxO1xuICAgICAgaWYoaGVhZGVycyl7XG4gICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtID0gMTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gY29udmVydCBkYXRhIHRvIG9iamVjdHNcbiAgICAgIGZvcih2YXIgaT0wLCBsZW49bGluZXMubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9ICQuY3N2LnRvQXJyYXkobGluZXNbaV0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgIGZvcih2YXIgaj0wOyBqIDxoZWFkZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgb2JqZWN0W2hlYWRlcnNbal1dID0gZW50cnlbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudHJhbnNmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkYXRhLnB1c2gob3B0aW9ucy50cmFuc2Zvcm0uY2FsbCh1bmRlZmluZWQsIG9iamVjdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEucHVzaChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyB1cGRhdGUgcm93IHN0YXRlXG4gICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtKys7XG4gICAgICB9XG5cbiAgICAgIC8vIG9uUG9zdFBhcnNlIGhvb2tcbiAgICAgIGlmKG9wdGlvbnMub25Qb3N0UGFyc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLm9uUG9zdFBhcnNlKGRhdGEsIG9wdGlvbnMuc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBwdXNoIHRoZSB2YWx1ZSB0byBhIGNhbGxiYWNrIGlmIG9uZSBpcyBkZWZpbmVkXG4gICAgICBpZighY29uZmlnLmNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLmNhbGxiYWNrKCcnLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgIC8qKlxuICAgICAqICQuY3N2LmZyb21BcnJheXMoYXJyYXlzKVxuICAgICAqIENvbnZlcnRzIGEgamF2YXNjcmlwdCBhcnJheSB0byBhIENTViBTdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgQW4gYXJyYXkgY29udGFpbmluZyBhbiBhcnJheSBvZiBDU1YgZW50cmllcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHVzZXItZGVmaW5lZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7Q2hhcmFjdGVyfSBbc2VwYXJhdG9yXSBBbiBvdmVycmlkZSBmb3IgdGhlIHNlcGFyYXRvciBjaGFyYWN0ZXIuIERlZmF1bHRzIHRvIGEgY29tbWEoLCkuXG4gICAgICogQHBhcmFtIHtDaGFyYWN0ZXJ9IFtkZWxpbWl0ZXJdIEFuIG92ZXJyaWRlIGZvciB0aGUgZGVsaW1pdGVyIGNoYXJhY3Rlci4gRGVmYXVsdHMgdG8gYSBkb3VibGUtcXVvdGUoXCIpLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGEgQ1NWIGZpbGUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgKHJlcHJlc2VudGluZyBlbnRyaWVzKS5cbiAgICAgKi9cbiAgICBmcm9tQXJyYXlzOiBmdW5jdGlvbihhcnJheXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBvcHRpb25zID0gKG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fSk7XG4gICAgICB2YXIgY29uZmlnID0ge307XG4gICAgICBjb25maWcuY2FsbGJhY2sgPSAoKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykgPyBjYWxsYmFjayA6IGZhbHNlKTtcbiAgICAgIGNvbmZpZy5zZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiAkLmNzdi5kZWZhdWx0cy5zZXBhcmF0b3I7XG4gICAgICBjb25maWcuZGVsaW1pdGVyID0gJ2RlbGltaXRlcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZGVsaW1pdGVyIDogJC5jc3YuZGVmYXVsdHMuZGVsaW1pdGVyO1xuXG4gICAgICB2YXIgb3V0cHV0ID0gJycsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgICBsaW5lVmFsdWVzLFxuICAgICAgICAgIGksIGo7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluZSA9IGFycmF5c1tpXTtcbiAgICAgICAgbGluZVZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBzdHJWYWx1ZSA9IChsaW5lW2pdID09PSB1bmRlZmluZWQgfHwgbGluZVtqXSA9PT0gbnVsbCkgPyAnJyA6IGxpbmVbal0udG9TdHJpbmcoKTtcbiAgICAgICAgICBpZiAoc3RyVmFsdWUuaW5kZXhPZihjb25maWcuZGVsaW1pdGVyKSA+IC0xKSB7XG4gICAgICAgICAgICBzdHJWYWx1ZSA9IHN0clZhbHVlLnJlcGxhY2UobmV3IFJlZ0V4cChjb25maWcuZGVsaW1pdGVyLCAnZycpLCBjb25maWcuZGVsaW1pdGVyICsgY29uZmlnLmRlbGltaXRlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVzY01hdGNoZXIgPSAnXFxufFxccnxTfEQnO1xuICAgICAgICAgIGVzY01hdGNoZXIgPSBlc2NNYXRjaGVyLnJlcGxhY2UoJ1MnLCBjb25maWcuc2VwYXJhdG9yKTtcbiAgICAgICAgICBlc2NNYXRjaGVyID0gZXNjTWF0Y2hlci5yZXBsYWNlKCdEJywgY29uZmlnLmRlbGltaXRlcik7XG5cbiAgICAgICAgICBpZiAoc3RyVmFsdWUuc2VhcmNoKGVzY01hdGNoZXIpID4gLTEpIHtcbiAgICAgICAgICAgIHN0clZhbHVlID0gY29uZmlnLmRlbGltaXRlciArIHN0clZhbHVlICsgY29uZmlnLmRlbGltaXRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGluZVZhbHVlcy5wdXNoKHN0clZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgKz0gbGluZVZhbHVlcy5qb2luKGNvbmZpZy5zZXBhcmF0b3IpICsgJ1xcclxcbic7XG4gICAgICB9XG5cbiAgICAgIC8vIHB1c2ggdGhlIHZhbHVlIHRvIGEgY2FsbGJhY2sgaWYgb25lIGlzIGRlZmluZWRcbiAgICAgIGlmKCFjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpZy5jYWxsYmFjaygnJywgb3V0cHV0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogJC5jc3YuZnJvbU9iamVjdHMob2JqZWN0cylcbiAgICAgKiBDb252ZXJ0cyBhIGphdmFzY3JpcHQgZGljdGlvbmFyeSB0byBhIENTViBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0cyBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB1c2VyLWRlZmluZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0NoYXJhY3Rlcn0gW3NlcGFyYXRvcl0gQW4gb3ZlcnJpZGUgZm9yIHRoZSBzZXBhcmF0b3IgY2hhcmFjdGVyLiBEZWZhdWx0cyB0byBhIGNvbW1hKCwpLlxuICAgICAqIEBwYXJhbSB7Q2hhcmFjdGVyfSBbZGVsaW1pdGVyXSBBbiBvdmVycmlkZSBmb3IgdGhlIGRlbGltaXRlciBjaGFyYWN0ZXIuIERlZmF1bHRzIHRvIGEgZG91YmxlLXF1b3RlKFwiKS5cbiAgICAgKiBAcGFyYW0ge0NoYXJhY3Rlcn0gW3NvcnRPcmRlcl0gU29ydCBvcmRlciBvZiBjb2x1bW5zIChuYW1lZCBhZnRlclxuICAgICAqICAgb2JqZWN0IHByb3BlcnRpZXMpLiBVc2UgJ2FscGhhJyBmb3IgYWxwaGFiZXRpYy4gRGVmYXVsdCBpcyAnZGVjbGFyZScsXG4gICAgICogICB3aGljaCBtZWFucywgdGhhdCBwcm9wZXJ0aWVzIHdpbGwgX3Byb2JhYmx5XyBhcHBlYXIgaW4gb3JkZXIgdGhleSB3ZXJlXG4gICAgICogICBkZWNsYXJlZCBmb3IgdGhlIG9iamVjdC4gQnV0IHdpdGhvdXQgYW55IGd1YXJhbnRlZS5cbiAgICAgKiBAcGFyYW0ge0NoYXJhY3RlciBvciBBcnJheX0gW21hbnVhbE9yZGVyXSBNYW51YWxseSBvcmRlciBjb2x1bW5zLiBNYXkgYmVcbiAgICAgKiBhIHN0cmluIGluIGEgc2FtZSBjc3YgZm9ybWF0IGFzIGFuIG91dHB1dCBvciBhbiBhcnJheSBvZiBoZWFkZXIgbmFtZXNcbiAgICAgKiAoYXJyYXkgaXRlbXMgd29uJ3QgYmUgcGFyc2VkKS4gQWxsIHRoZSBwcm9wZXJ0aWVzLCBub3QgcHJlc2VudCBpblxuICAgICAqIGBtYW51YWxPcmRlcmAgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIGluIGFjY29yZGFuY2Ugd2l0aCBgc29ydE9yZGVyYFxuICAgICAqIG9wdGlvbi4gU28gdGhlIGBtYW51YWxPcmRlcmAgYWx3YXlzIHRha2VzIHByZWZlcmVuY2UsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBnZW5lcmF0ZXMgYSBDU1YgZmlsZSBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHMgKG5hbWU6dmFsdWUgcGFpcnMpLlxuICAgICAqIEl0IHN0YXJ0cyBieSBkZXRlY3RpbmcgdGhlIGhlYWRlcnMgYW5kIGFkZGluZyB0aGVtIGFzIHRoZSBmaXJzdCBsaW5lIG9mXG4gICAgICogdGhlIENTViBmaWxlLCBmb2xsb3dlZCBieSBhIHN0cnVjdHVyZWQgZHVtcCBvZiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBmcm9tT2JqZWN0czogZnVuY3Rpb24ob2JqZWN0cywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIG9wdGlvbnMgPSAob3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucyA6IHt9KTtcbiAgICAgIHZhciBjb25maWcgPSB7fTtcbiAgICAgIGNvbmZpZy5jYWxsYmFjayA9ICgoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSA/IGNhbGxiYWNrIDogZmFsc2UpO1xuICAgICAgY29uZmlnLnNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6ICQuY3N2LmRlZmF1bHRzLnNlcGFyYXRvcjtcbiAgICAgIGNvbmZpZy5kZWxpbWl0ZXIgPSAnZGVsaW1pdGVyJyBpbiBvcHRpb25zID8gb3B0aW9ucy5kZWxpbWl0ZXIgOiAkLmNzdi5kZWZhdWx0cy5kZWxpbWl0ZXI7XG4gICAgICBjb25maWcuaGVhZGVycyA9ICdoZWFkZXJzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5oZWFkZXJzIDogJC5jc3YuZGVmYXVsdHMuaGVhZGVycztcbiAgICAgIGNvbmZpZy5zb3J0T3JkZXIgPSAnc29ydE9yZGVyJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zb3J0T3JkZXIgOiAnZGVjbGFyZSc7XG4gICAgICBjb25maWcubWFudWFsT3JkZXIgPSAnbWFudWFsT3JkZXInIGluIG9wdGlvbnMgPyBvcHRpb25zLm1hbnVhbE9yZGVyIDogW107XG4gICAgICBjb25maWcudHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLm1hbnVhbE9yZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWcubWFudWFsT3JkZXIgPSAkLmNzdi50b0FycmF5KGNvbmZpZy5tYW51YWxPcmRlciwgY29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3JpZ09iamVjdHMgPSBvYmplY3RzO1xuICAgICAgICBvYmplY3RzID0gW107XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmlnT2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iamVjdHMucHVzaChjb25maWcudHJhbnNmb3JtLmNhbGwodW5kZWZpbmVkLCBvcmlnT2JqZWN0c1tpXSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9ICQuY3N2LmhlbHBlcnMuY29sbGVjdFByb3BlcnR5TmFtZXMob2JqZWN0cyk7XG5cbiAgICAgIGlmIChjb25maWcuc29ydE9yZGVyID09PSAnYWxwaGEnKSB7XG4gICAgICAgIHByb3BzLnNvcnQoKTtcbiAgICAgIH0gLy8gZWxzZSB7fSAtIG5vdGhpbmcgdG8gZG8gZm9yICdkZWNsYXJlJyBvcmRlclxuXG4gICAgICBpZiAoY29uZmlnLm1hbnVhbE9yZGVyLmxlbmd0aCA+IDApIHtcblxuICAgICAgICB2YXIgcHJvcHNNYW51YWwgPSBbXS5jb25jYXQoY29uZmlnLm1hbnVhbE9yZGVyKTtcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIGZvciAocCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgICAgIGlmIChwcm9wc01hbnVhbC5pbmRleE9mKCBwcm9wc1twXSApIDwgMCkge1xuICAgICAgICAgICAgcHJvcHNNYW51YWwucHVzaCggcHJvcHNbcF0gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMgPSBwcm9wc01hbnVhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG8sIHAsIGxpbmUsIG91dHB1dCA9IFtdLCBwcm9wTmFtZTtcbiAgICAgIGlmIChjb25maWcuaGVhZGVycykge1xuICAgICAgICBvdXRwdXQucHVzaChwcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobyA9IDA7IG8gPCBvYmplY3RzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgZm9yIChwID0gMDsgcCA8IHByb3BzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgcHJvcE5hbWUgPSBwcm9wc1twXTtcbiAgICAgICAgICBpZiAocHJvcE5hbWUgaW4gb2JqZWN0c1tvXSAmJiB0eXBlb2Ygb2JqZWN0c1tvXVtwcm9wTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxpbmUucHVzaChvYmplY3RzW29dW3Byb3BOYW1lXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmUucHVzaCgnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKGxpbmUpO1xuICAgICAgfVxuXG4gICAgICAvLyBwdXNoIHRoZSB2YWx1ZSB0byBhIGNhbGxiYWNrIGlmIG9uZSBpcyBkZWZpbmVkXG4gICAgICByZXR1cm4gJC5jc3YuZnJvbUFycmF5cyhvdXRwdXQsIG9wdGlvbnMsIGNvbmZpZy5jYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIC8vIE1haW50ZW5hbmNlIGNvZGUgdG8gbWFpbnRhaW4gYmFja3dhcmQtY29tcGF0aWJpbGl0eVxuICAvLyBXaWxsIGJlIHJlbW92ZWQgaW4gcmVsZWFzZSAxLjBcbiAgJC5jc3ZFbnRyeTJBcnJheSA9ICQuY3N2LnRvQXJyYXk7XG4gICQuY3N2MkFycmF5ID0gJC5jc3YudG9BcnJheXM7XG4gICQuY3N2MkRpY3Rpb25hcnkgPSAkLmNzdi50b09iamVjdHM7XG5cbiAgLy8gQ29tbW9uSlMgbW9kdWxlIGlzIGRlZmluZWRcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSAkLmNzdjtcbiAgfVxuXG59KS5jYWxsKCB0aGlzICk7XG4iLCJyZXF1aXJlKCdqcXVlcnktY3N2Jyk7XG5cbmNvbnN0IEFQUF9MSU5LID0gYGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2Zvcm1zL2QvZS8xRkFJcFFMU2Y5VGREZUtVVlFfbVF0amZKTTNmZ0V3dDYybHVoR0NzdlJvaWVieDQyN0Y5Wk8yUS92aWV3Zm9ybT9lbnRyeS41Njg1OTE1NTU9YDtcblxubGV0IGlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lucHV0LXNjaG9vbCcpO1xubGV0IHNlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWxlY3Qtc2Nob29sJyk7XG5sZXQgYnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1dHRvbi1mb3JtJyk7XG5cbiQuZ2V0KCcuL3B1YmxpYy9maWxlcy9zY2hvb2xzLmNzdicsIChkYXRhKSA9PiB7XG5cdGxldCBzY2hvb2xzID0gW107XG5cdGxldCBjc3YgPSAkLmNzdi50b0FycmF5cyhkYXRhKTtcblx0Y3N2LmZvckVhY2goKHJvdykgPT4ge1xuXHRcdGxldCBzY2hvb2wgPSByb3dbMF07XG5cdFx0c2Nob29scy5wdXNoKHNjaG9vbCk7XG5cdFx0bGV0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuXHRcdFx0b3B0aW9uLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBzY2hvb2wpO1xuXHRcdFx0b3B0aW9uLmlubmVyVGV4dCA9IHNjaG9vbDtcblx0XHRcdHNlbGVjdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuXHR9KTtcblxuXHRidXR0b24ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuXHRidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuXHRcdGxldCB5b3VyU2Nob29sID0gc2VsZWN0LnZhbHVlO1xuXHRcdGNvbnNvbGUubG9nKHlvdXJTY2hvb2wpO1xuXHRcdHdpbmRvdy5sb2NhdGlvbiA9IGAke0FQUF9MSU5LfSR7eW91clNjaG9vbH1gO1xuXHR9KTtcblxufSk7Il19\n"]}